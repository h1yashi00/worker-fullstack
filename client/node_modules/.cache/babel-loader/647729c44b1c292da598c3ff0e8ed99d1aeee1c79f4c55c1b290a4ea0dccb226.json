{"ast":null,"code":"// src/utils/url.ts\nvar splitPath = path => {\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  return paths;\n};\nvar splitRoutingPath = path => {\n  const groups = [];\n  for (let i = 0;;) {\n    let replaced = false;\n    path = path.replace(/\\{[^}]+\\}/g, m => {\n      const mark = `@\\\\${i}`;\n      groups[i] = [mark, m];\n      i++;\n      replaced = true;\n      return mark;\n    });\n    if (!replaced) {\n      break;\n    }\n  }\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  for (let i = groups.length - 1; i >= 0; i--) {\n    const [mark] = groups[i];\n    for (let j = paths.length - 1; j >= 0; j--) {\n      if (paths[j].indexOf(mark) !== -1) {\n        paths[j] = paths[j].replace(mark, groups[i][1]);\n        break;\n      }\n    }\n  }\n  return paths;\n};\nvar patternCache = {};\nvar getPattern = label => {\n  if (label === \"*\") {\n    return \"*\";\n  }\n  const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (match) {\n    if (!patternCache[label]) {\n      if (match[2]) {\n        patternCache[label] = [label, match[1], new RegExp(\"^\" + match[2] + \"$\")];\n      } else {\n        patternCache[label] = [label, match[1], true];\n      }\n    }\n    return patternCache[label];\n  }\n  return null;\n};\nvar getPathFromURL = function (url) {\n  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const queryIndex = url.indexOf(\"?\", 8);\n  const result = url.substring(url.indexOf(\"/\", 8), queryIndex === -1 ? url.length : queryIndex);\n  if (strict === false && result.endsWith(\"/\")) {\n    return result.slice(0, -1);\n  }\n  return result;\n};\nvar getQueryStringFromURL = url => {\n  const queryIndex = url.indexOf(\"?\", 8);\n  const result = queryIndex !== -1 ? url.slice(queryIndex + 1) : \"\";\n  return result;\n};\nvar mergePath = function () {\n  let p = \"\";\n  let endsWithSlash = false;\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  for (let path of paths) {\n    if (p.endsWith(\"/\")) {\n      p = p.slice(0, -1);\n      endsWithSlash = true;\n    }\n    if (!path.startsWith(\"/\")) {\n      path = `/${path}`;\n    }\n    if (path === \"/\" && endsWithSlash) {\n      p = `${p}/`;\n    } else if (path !== \"/\") {\n      p = `${p}${path}`;\n    }\n    if (path === \"/\" && p === \"\") {\n      p = \"/\";\n    }\n  }\n  return p;\n};\nvar checkOptionalParameter = path => {\n  const match = path.match(/(^.+)(\\/\\:[^\\/]+)\\?$/);\n  if (!match) return null;\n  const base = match[1];\n  const optional = base + match[2];\n  return [base, optional];\n};\nvar removeFragment = queryString => {\n  const fragIndex = queryString.indexOf(\"#\");\n  if (fragIndex !== -1) {\n    queryString = queryString.slice(0, fragIndex);\n  }\n  return queryString;\n};\nvar getQueryParam = (queryString, key) => {\n  queryString = removeFragment(queryString);\n  const results = {};\n  while (true) {\n    const andIndex = queryString.indexOf(\"&\");\n    let strings = \"\";\n    if (andIndex === -1) {\n      strings = queryString;\n    } else {\n      strings = queryString.substring(0, andIndex);\n    }\n    const eqIndex = strings.indexOf(\"=\");\n    if (eqIndex !== -1) {\n      const v = strings.substring(eqIndex + 1);\n      const k = strings.substring(0, eqIndex);\n      if (key === k) {\n        return /\\%/.test(v) ? decodeURI(v) : v;\n      } else {\n        results[k] || (results[k] = v);\n      }\n    } else if (strings === key) {\n      return \"\";\n    }\n    if (andIndex === -1) break;\n    queryString = queryString.substring(andIndex + 1, queryString.length);\n  }\n  if (key) return null;\n  return results;\n};\nvar getQueryParams = (queryString, key) => {\n  queryString = removeFragment(queryString);\n  const results = {};\n  for (const strings of queryString.split(\"&\")) {\n    let [k, v] = strings.split(\"=\");\n    if (v === void 0) v = \"\";\n    results[k] || (results[k] = []);\n    results[k].push(v.indexOf(\"%\") !== -1 ? decodeURI(v) : v);\n  }\n  if (key) return results[key] ? results[key] : null;\n  return results;\n};\nexport { checkOptionalParameter, getPathFromURL, getPattern, getQueryParam, getQueryParams, getQueryStringFromURL, mergePath, splitPath, splitRoutingPath };","map":{"version":3,"names":["splitPath","path","paths","split","shift","splitRoutingPath","groups","i","replaced","replace","m","mark","length","j","indexOf","patternCache","getPattern","label","match","RegExp","getPathFromURL","url","strict","arguments","undefined","queryIndex","result","substring","endsWith","slice","getQueryStringFromURL","mergePath","p","endsWithSlash","_len","Array","_key","startsWith","checkOptionalParameter","base","optional","removeFragment","queryString","fragIndex","getQueryParam","key","results","andIndex","strings","eqIndex","v","k","test","decodeURI","getQueryParams","push"],"sources":["/Users/hankake/web/react-workers/client/node_modules/hono/dist/utils/url.js"],"sourcesContent":["// src/utils/url.ts\nvar splitPath = (path) => {\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  return paths;\n};\nvar splitRoutingPath = (path) => {\n  const groups = [];\n  for (let i = 0; ; ) {\n    let replaced = false;\n    path = path.replace(/\\{[^}]+\\}/g, (m) => {\n      const mark = `@\\\\${i}`;\n      groups[i] = [mark, m];\n      i++;\n      replaced = true;\n      return mark;\n    });\n    if (!replaced) {\n      break;\n    }\n  }\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  for (let i = groups.length - 1; i >= 0; i--) {\n    const [mark] = groups[i];\n    for (let j = paths.length - 1; j >= 0; j--) {\n      if (paths[j].indexOf(mark) !== -1) {\n        paths[j] = paths[j].replace(mark, groups[i][1]);\n        break;\n      }\n    }\n  }\n  return paths;\n};\nvar patternCache = {};\nvar getPattern = (label) => {\n  if (label === \"*\") {\n    return \"*\";\n  }\n  const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (match) {\n    if (!patternCache[label]) {\n      if (match[2]) {\n        patternCache[label] = [label, match[1], new RegExp(\"^\" + match[2] + \"$\")];\n      } else {\n        patternCache[label] = [label, match[1], true];\n      }\n    }\n    return patternCache[label];\n  }\n  return null;\n};\nvar getPathFromURL = (url, strict = true) => {\n  const queryIndex = url.indexOf(\"?\", 8);\n  const result = url.substring(url.indexOf(\"/\", 8), queryIndex === -1 ? url.length : queryIndex);\n  if (strict === false && result.endsWith(\"/\")) {\n    return result.slice(0, -1);\n  }\n  return result;\n};\nvar getQueryStringFromURL = (url) => {\n  const queryIndex = url.indexOf(\"?\", 8);\n  const result = queryIndex !== -1 ? url.slice(queryIndex + 1) : \"\";\n  return result;\n};\nvar mergePath = (...paths) => {\n  let p = \"\";\n  let endsWithSlash = false;\n  for (let path of paths) {\n    if (p.endsWith(\"/\")) {\n      p = p.slice(0, -1);\n      endsWithSlash = true;\n    }\n    if (!path.startsWith(\"/\")) {\n      path = `/${path}`;\n    }\n    if (path === \"/\" && endsWithSlash) {\n      p = `${p}/`;\n    } else if (path !== \"/\") {\n      p = `${p}${path}`;\n    }\n    if (path === \"/\" && p === \"\") {\n      p = \"/\";\n    }\n  }\n  return p;\n};\nvar checkOptionalParameter = (path) => {\n  const match = path.match(/(^.+)(\\/\\:[^\\/]+)\\?$/);\n  if (!match)\n    return null;\n  const base = match[1];\n  const optional = base + match[2];\n  return [base, optional];\n};\nvar removeFragment = (queryString) => {\n  const fragIndex = queryString.indexOf(\"#\");\n  if (fragIndex !== -1) {\n    queryString = queryString.slice(0, fragIndex);\n  }\n  return queryString;\n};\nvar getQueryParam = (queryString, key) => {\n  queryString = removeFragment(queryString);\n  const results = {};\n  while (true) {\n    const andIndex = queryString.indexOf(\"&\");\n    let strings = \"\";\n    if (andIndex === -1) {\n      strings = queryString;\n    } else {\n      strings = queryString.substring(0, andIndex);\n    }\n    const eqIndex = strings.indexOf(\"=\");\n    if (eqIndex !== -1) {\n      const v = strings.substring(eqIndex + 1);\n      const k = strings.substring(0, eqIndex);\n      if (key === k) {\n        return /\\%/.test(v) ? decodeURI(v) : v;\n      } else {\n        results[k] || (results[k] = v);\n      }\n    } else if (strings === key) {\n      return \"\";\n    }\n    if (andIndex === -1)\n      break;\n    queryString = queryString.substring(andIndex + 1, queryString.length);\n  }\n  if (key)\n    return null;\n  return results;\n};\nvar getQueryParams = (queryString, key) => {\n  queryString = removeFragment(queryString);\n  const results = {};\n  for (const strings of queryString.split(\"&\")) {\n    let [k, v] = strings.split(\"=\");\n    if (v === void 0)\n      v = \"\";\n    results[k] || (results[k] = []);\n    results[k].push(v.indexOf(\"%\") !== -1 ? decodeURI(v) : v);\n  }\n  if (key)\n    return results[key] ? results[key] : null;\n  return results;\n};\nexport {\n  checkOptionalParameter,\n  getPathFromURL,\n  getPattern,\n  getQueryParam,\n  getQueryParams,\n  getQueryStringFromURL,\n  mergePath,\n  splitPath,\n  splitRoutingPath\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}